PROCESS MANAGEMENET (PM2)

it keeps a process running unless stopped explicitely

features 
- keeps the app running continuously
- automatically restarts the cached apps 
- provided monitoring and logging 
- supports running multiple app instances for better performance

- create an EC2 instance
- install node in vm  
- install npm in vm 
- create a file index.js 
- run the server

- lsof command in ubuntu gives whatever process are running on all ports
- to get the process running on port 3000 
do lsof -i :3000
- to kill the running process run [kill processid]
- the server will stop running

to start the server with pm2 
- sudo i -g pm2
- to start with pm2 : pm2 start app.js 

now even if we kill the server then it will keep on running

- curl app.js : to check the api endpoint in the terminal

pm2 just restarts the server instantly whenever the server starts
pm2 examples will give all the commands for pm2

CI-CD : Continuous Integeration - Continuous Deployment

continuous integration is a development practice where a developer integrates the code in a shared repo multiple times
the integrations are verified bu 
1. building the project 
2. running automated tests 

continuous deployment is the process of subsequently deploying your code in different enviornments

there are generatlly three env in any appliction 
1. Dev : developer facing
2. Staging / Test : testing 
3. Prod : client facing 


In a codebase if a file is inside of `.github/workflows`

It is considered a CI file which means github will run the contents of the files whenever the conditions are me

Some useful cases where this might be handy:

- To run unit/integrated tests
- To run lint/format checking
- To build the application
- Deploy it whenever someone pushes their code

.github/workflows/hello.yml

---------------------------------------------------------------------------------------------------------------------
name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 🚀
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "🎉 The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "💡 The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "🖥️ The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "🍏 This job's status is ${{ job.status }}."

---------------------------------------------------------------------------------------------------------------------

TODO : do the ci-cd with github actions for a next js project 


---------------------------------------------------------------------------------------------------------------------

creating a monorepo with nodejs, nextjs, prisma and postgres and deploying it. 

1. npx create-turbo@latest
2. use pnpm as packege manager
3. get rid of one nextjs project : docs inside hte app
4. create two new backend, http-server, ws-server
5. create the prisma package
6. create the folder prisma in packages
7. inside prisma : npm init -y 
8. inside the package.json, change the name to @repo/db, remove the scripts part too
9. inside the prisma npx tsc --init
10. inside the tsconfig, extend the base config
{
  "extends":"@repo/tyescript-config/base.json"
}
11. create the tsconfig as teh devDEpendency in package.json
 "devDependencies": {
    "@repo/typescript-config": "workspace:*"
  },
  -> if pnpm, "workspace:*", for npm/yarn only "*"
12. pnpm add prisma 
13. npx prisma init -> this will create a schema.prisma file, where we can write the schemas
14. create a user schema in schemas.prisma 
model User {
  id       String @id @default(uuid())
  username String @unique
  password String
}

15. get a fresh db from neon db
16. copy the connection string and paste it into the .env 
17. run the command  npx prisma migrate dev     
18. run the command npx prisma generate
19. create the src/index.ts and write the prisma client export code there 
20. in the apps/web/package.json add the devDepencdency  "@repo/db": "workspace:*",

----------------
pushing in github 

create a repo on github, and copy the http link 

1. git remote add origin [http link]
2. git push origin HEAD 
------------------

21. do a global pnpm install
22. start creating the http server 
npm init -y
npx tsc --init
in the tsconfig :
{
  "extends": "@repo/typescript-config/base.json",

"compilerOptions":{
  "rootDir" : "./src",
  "outDir" : "./dist"
  }
}
in the package.json add the devDep:
 "devDependencies": {
    "@repo/db": "workspace:*",
    "@repo/typescript-config": "workspace:*"
  },

add the scripts 
 "scripts": {
    "build": "tsc -b",
    "dev": "npm run build && npm run start",
    "start": "node dist/index.js"
  },

-------------------------

start writing the application logic for the http server 
1. pnpm add express @types/express
2. write the express boilerplate 
3. create a post signup route
4. import the db logic from client -> @repo/db/client


-------------------------
start writing the application logic for the ws server 
1. pnpm add ws @types/ws
2. add the db client 
3. store the username and password in the db


----------------------------------

add the fetching logic in next js frontend -> in apps/web/app/page.tsx

import { client } from "@repo/db/client";

export default async function Home() {
  const user = await client.user.findFirst();

  return (
    <div>
      {user?.username}
      {user?.password}
    </div>
  );
}

----------------------------------

test the ws-server endpoint
test the next js frontend
test the http backend

in any codebase, thre is a dev branch then there is a staging branch tehn there is the production branch 

deploying the monorepo 

1. create 2 servers 
create a new digital ocean project 
create a new droplet and name it dev 
create another droplet and name it prod

2. add node, pnpm and nginx to both the sevrers 
ssh into both the machines prod and dev 

ssh -i ~/.ssh/id_rsa_do root@206.189.137.51

add node and nginx to both the machines

adding node :
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
source ~/.bashrc
nvm install --lts

adding nginx: 
sudo apt-get upgrade
sudo apt install nginx

adding pnpm : 
npm install -g pnpm 

3. clone the monorepo to both the sevrers 
git clone the https link 

4. start 3 processes (next, ws, http)
pnpm install (globally)

create two dbs for production and staging
copy the db_url and paste it in the packages/prisma/.env for both dev and prod respectively
migrate the dbs 
npx prisma migrate dev

start the ws server, http server and the frontend
- do a global pnpm run build 
- use the process manager to start the processes 
- npm install -g pm2 
- go to the http-server repo : pm2 start npm --name "http-server" -- start
- pm2 start npm --name "ws-server" -- start
- pm2 start npm --name "fe-server" -- start

use pm2 list for the list of processes 

run the same commands on the dev machine


check by going to the public id / 3000 -> check the url 

5. point our domain names to the respective servers  

go to squarespace, buy a domain name 

add records for the domain name 
a-http.domain.com
a-ws.domain.com
a-fe.domain.com

make all of them A records and add the respective ip addresses

and 

staging.a-http.domain.com
staging.a-ws.domain.com
staging.a-fe.domain.com

go to the dnschecker.com to see the dns is available or not
then do to dns:port to check the website 

6. refresh the nginx config 

- sudo vi /etc/nginx/nginx.conf
- delete all the configurations 
- get the nginx conf for three processes and then paste them you will have to write three server configurations 
- do the same for the dev server 

7. test that everything is working

this is the manual deployment process on vm

after there are any changes to the codebase you manually redeploy the application

- ssh into dev 
- cd project name 
- git pull
- pm2 restart

--------------------------------------------------------------------------------------------------------------

Creating a CD pipeline 

1. create a .github folder 
2. create a workflows folder 
3. create two files cd_prod.yml and cd_staging.yml 
