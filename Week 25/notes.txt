PROCESS MANAGEMENET (PM2)

it keeps a process running unless stopped explicitely

features 
- keeps the app running continuously
- automatically restarts the cached apps 
- provided monitoring and logging 
- supports running multiple app instances for better performance

- create an EC2 instance
- install node in vm  
- install npm in vm 
- create a file index.js 
- run the server

- lsof command in ubuntu gives whatever process are running on all ports
- to get the process running on port 3000 
do lsof -i :3000
- to kill the running process run [kill processid]
- the server will stop running

to start the server with pm2 
- sudo i -g pm2
- to start with pm2 : pm2 start app.js 

now even if we kill the server then it will keep on running

- curl app.js : to check the api endpoint in the terminal

pm2 just restarts the server instantly whenever the server starts
pm2 examples will give all the commands for pm2

CI-CD : Continuous Integeration - Continuous Deployment

continuous integration is a development practice where a developer integrates the code in a shared repo multiple times
the integrations are verified bu 
1. building the project 
2. running automated tests 

continuous deployment is the process of subsequently deploying your code in different enviornments

there are generatlly three env in any appliction 
1. Dev : developer facing
2. Staging / Test : testing 
3. Prod : client facing 


In a codebase if a file is inside of `.github/workflows`

It is considered a CI file which means github will run the contents of the files whenever the conditions are me

Some useful cases where this might be handy:

- To run unit/integrated tests
- To run lint/format checking
- To build the application
- Deploy it whenever someone pushes their code

.github/workflows/hello.yml

---------------------------------------------------------------------------------------------------------------------
name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 🚀
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "🎉 The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "💡 The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "🖥️ The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "🍏 This job's status is ${{ job.status }}."

---------------------------------------------------------------------------------------------------------------------

TODO : do the ci-cd with github actions for a next js project 


---------------------------------------------------------------------------------------------------------------------

creating a monorepo with nodejs, nextjs, prisma and postgres and deploying it. 

1. npx create-turbo@latest
2. use pnpm as packege manager
3. get rid of one nextjs project : docs inside hte app
4. create two new backend, http-server, ws-server
5. create the prisma package
6. create the folder prisma in packages
7. inside prisma : npm init -y 
8. inside the package.json, change the name to @repo/db, remove the scripts part too
9. inside the prisma npx tsc --init
10. inside the tsconfig, extend the base config
{
  "extends":"@repo/tyescript-config/base.json"
}
11. create the tsconfig as teh devDEpendency in package.json
 "devDependencies": {
    "@repo/typescript-config": "workspace:*"
  },
  -> if pnpm, "workspace:*", for npm/yarn only "*"
12. pnpm add prisma 
13. npx prisma init -> this will create a schema.prisma file, where we can write the schemas
14. create a user schema in schemas.prisma 
model User {
  id       String @id @default(uuid())
  username String @unique
  password String
}

15. get a fresh db from neon db
16. copy the connection string and paste it into the .env 
17. run the command  npx prisma migrate dev     
18. run the command npx prisma generate
19. create the src/index.ts and write the prisma client export code there 
20. in the apps/web/package.json add the devDepencdency  "@repo/db": "workspace:*",

----------------
pushing in github 

create a repo on github, and copy the http link 

1. git remote add origin [http link]
2. git push origin HEAD 
------------------

21. do a global pnpm install
22. start creating the http server 
npm init -y
npx tsc --init
in the tsconfig :
{
  "extends": "@repo/typescript-config/base.json",

"compilerOptions":{
  "rootDir" : "./src",
  "outDir" : "./dist"
  }
}
